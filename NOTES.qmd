---
title: "Notizen"
date: "`r Sys.Date()`" # inserts the date of compiling
editor: source
execute:
  eval: false   # not running code, as this is just for notes purposes
  echo: true
  warning: false
  message: false
  cache: false # true will prevent embed-resources
format: 
  html:
    theme: cerulean
    fontsize: 0.85em
    toc: true
    toc-location: left
    toc-depth: 2
    embed-resources: true # will make standalone html file
    code-fold: show
    code-tools: true
    code-link: true
editor_options: 
  chunk_output_type: console
---

\

# Stichpunkte und Themen(Ideen)speicher

- Umgang Längsschnitt (Stichwort: sampling weights)
- Fehlende Werte mit Werten aus einem späteren Zeitpunkt auffüllen, so gemacht bei Big 5, sonst aber nicht: Wo kommt es noch in Frage?
- Noten z standardisieren?
- Current study phase = MZP2; Was, wenn Personen da schon kein Lehramt mehr studieren. Fachwechsler*innen filtern? Oder egal, weil am Ende in der Variable Dropout explizit nach Lehramt geschaut wird und es dadurch egal ist, wann der Abbruch (inkl. Wechsel) passiert ist (Sonst wäre es Abbruch zwischen MZP 2 und 3, oder?) ...aber eine gute Integration in einem anderen Fach ist inhaltlich uninteressant
- LPA, LCA oder Mixture Model (in den R-Skripten sind Paper und Tutorials verlinkt, Paper von J. Bauer verfügt auch über R-Skripte im Anhang)
- Packages geben Bayes Faktor nicht aus, mit Shiny App keinen Erfolg <a href="https://robert-fox.shinyapps.io/BF_cmP_Calculator/"> Link </a> (Wie berechnen? Vermutlich gelöst)
- Benutzen alle LCA (LPA) Maximum Likelihood Schätzer (beziehungsweise ist der EM-Algorithmus ein ML-Schätzer (Hintegrund: In Präreg. Nutzung von MLE genannt).
- Problem: Fast keine Daten nur Nutzung von Lerngelegenheiten - NA bei über 90% (Aber gültige Beobachtungen > 200)
- Movtivationale Lagen als relativen Wert abbilden?
\
- Lehramtsstudierendenpanel oder alle, die angeben Lehramt zu studieren nutzen?<br /> 
  ? Eher eine abstrakte Frage
\
- "Though it may be tempting to simply extract individuals’ modal class assignment from the results and use this as a manifest variable for further analyses, it is well known that this procedure leads to biased results and is inappropriate. The reason is that this hard classification disregards the classification uncertainty." Oh no! tidySEM hat dafür zwar die Funktion BCH()...aber eine Mediation, so wie geplant, ist damit nach erster Durchsicht nicht möglich. Work around: In our practice, we use a probability cut-off of ≥ 0.5 to assign class. https://doi.org/10.1097%2FCCM.0000000000004710
- "poLCA treats all manifest variables as qualitative/categorical/nominal – NOT as ordinal. The model may also be fit to manifest variables that are ordinal, but they will be treated as nominal. In practice, this does not usually restrict analyses in any meaningful way." (?)
\
\


# Abweichungen von der Praeregistrierung

## Andere Items genutzt
- Age of enrollment
- Type of higher education inst

## Datenanalyse
- Imputation LCA: "No data imputations were performed, as the likelihood approach of LCA accommodates the inclusion of patients with missing values." (Vermunt JK, Magidson J. Latent Gold 4.0 User’s Guide. Belmont, MA: Statistical Innovations; 2005) (?)
- par_ocu: 3 Teilung (working class, intermediate class, upper class) --> hat großen Effekt auf die Klassenlösung, bei 2 Kategorien Entropie ~ 30%, so bei 65%

\
\


# Code Check 19.1.2024

## `par_edu` vs. `par_ocu`
Du hattest dich ja gewundert, warum Studierende oftmals Eltern ohne Hochschulabschluss haben (`par_edu`), die Eltern dann aber keine mixed oder working class sind (`par_ocu`): Vielleicht ist deine Um codierung in `par_ocu` nicht so optimal. Du machst

```{r}
  dplyr::mutate(par_ocu = case_when((t731403_g8 >= 8 | t731453_g8 >= 8) ~ 1,    
                                    (t731403_g8 <= 7 | t731453_g8 <= 7) ~ 2,
                                    TRUE ~ as.numeric(NA)))
                                    # 1 = working class, 
                                    # 2 = mixed and service class
```

Dabei ist beispielsweise die Ausprägung 4 (="Angestellte der ausführenden nicht‐manuellen Klasse mit gering qualifizierten Routinetätigkeiten")laut Wikipedia beispielsweise eine Kassiererin. Wäre das nicht auch working class? D.h. woher hast du die Unterscheidung in working class und mixed + service class? Gibt es hier vielleicht eine gute Quelle? \

Außerdem stimmt glaube ich eine der `case_when()` Bedingungen nicht. Wenn du die Bedingung `t731403_g8 >= 8 | t731453_g8 >= 8) ~ 1,` setzt, dann wird auch Personen eine 1 vergeben, von denen **ein** Elternteil `>= 8` ist. D.h. alle die "mixed" Eltern haben bekommen auch eine 1. Das war glaube ich nicht deine Absicht, oder? Für die working class müssten deiner Definition nach beide Eltern Werte von `>= 8` haben, richtig? Dann müsste heißen:

```{r}
  dplyr::mutate(par_ocu = case_when((t731403_g8 >= 8 & t731453_g8 >= 8) ~ 1,    
                                    (t731403_g8 <= 7 | t731453_g8 <= 7) ~ 2,
                                    TRUE ~ as.numeric(NA)))
                                    # 1 = working class, 
                                    # 2 = mixed and service class
```

Siehe `&` statt `|` Verknüpfung.

## Zwischenwerte
Das ist hier kein Problem, trotzdem für die Zukunft: Hier müssen die Enden der Bedingungen jeweils aneinander ran reichen. Werte, die z.B. zwischen 1.5. und 1.6 liegen, würden in dem Skript nicht abgedeckt werden.

```{r}
  dplyr::mutate(paa_gpa = case_when(ts11218 >= 3.6 &  ts11218 <= 4.0 ~ 1,
                                    ts11218 >= 2.6 &  ts11218 <= 3.5 ~ 2,
                                    ts11218 >= 1.6 &  ts11218 <= 2.5 ~ 3,
                                    ts11218 >= 1.0 &  ts11218 <= 1.5 ~ 4,
                                    TRUE ~ as.numeric(NA)))  %>%
                                    # 1 = sufficient, 2 = satisfactory, 
                                    # 3 = good, 4 = very good)
```


Also müsstest du 2 Dinge machen: (1) die Werte direkt aneinander anschließen und (2) auf einer Seite das `=` entfernen, damit die Bedingungen eindeutig definiert sind. Beispiel für hier:

```{r}
  dplyr::mutate(paa_gpa = case_when(ts11218 >= 3.6 &  ts11218 <= 4.0 ~ 1,
                                    ts11218 >= 2.6 &  ts11218 < 3.6 ~ 2,
                                    ts11218 >= 1.6 &  ts11218 < 2.6 ~ 3,
                                    ts11218 >= 1.0 &  ts11218 < 1.6 ~ 4,
                                    TRUE ~ as.numeric(NA)))  %>%
                                    # 1 = sufficient, 2 = satisfactory, 
                                    # 3 = good, 4 = very good)
```

## Sorry it's superseded

Das hier ist "alter" Code:

```{r}
data6 <- data5 %>% 
  dplyr::mutate_all( ~ ifelse(is.nan(.), NA, .))
```

`mutate_all()` und `mutate_at()` etc wurde abgelöst. In deinem Fall von `across()`. So heißt das heute bei den coolen Kids:

```{r}
data6 <- data5 %>% 
  dplyr::mutate(across(everything(), ~ ifelse(is.nan(.x), NA, .x)))
```



